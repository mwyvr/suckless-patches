diff -Np1 dwm-6.3/config.def.h dwm-mw-master/config.def.h
*** dwm-6.3/config.def.h	2022-01-07 03:42:18.000000000 -0800
--- dwm-mw-master/config.def.h	2022-02-10 12:15:49.315632683 -0800
*************** static const unsigned int borderpx  = 1;
*** 5,10 ****
  static const unsigned int snap      = 32;       /* snap pixel */
  static const int showbar            = 1;        /* 0 means no bar */
  static const int topbar             = 1;        /* 0 means bottom bar */
! static const char *fonts[]          = { "monospace:size=10" };
! static const char dmenufont[]       = "monospace:size=10";
  static const char col_gray1[]       = "#222222";
--- 5,12 ----
  static const unsigned int snap      = 32;       /* snap pixel */
+ static const unsigned int bar_hpad  = 4;        /* default 2px above/below font size  */
+ static const int rmaster            = 0;        /* 1 means master-area is initially on the right */
  static const int showbar            = 1;        /* 0 means no bar */
  static const int topbar             = 1;        /* 0 means bottom bar */
! static const char *fonts[]          = { "monospace:size=11" };
! static const char dmenufont[]       = "monospace:size=11";
  static const char col_gray1[]       = "#222222";
*************** static const char col_gray4[]       = "#
*** 14,19 ****
  static const char col_cyan[]        = "#005577";
  static const char *colors[][3]      = {
! 	/*               fg         bg         border   */
! 	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
! 	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
  };
--- 16,30 ----
  static const char col_cyan[]        = "#005577";
+ static const char col_gunmetal[]    = "#1F2933";
+ static const char col_charcoal[]    = "#3B5062";
+ static const char col_platinum[]    = "#EAEBEB";
+ static const char col_gainsboro[]    = "#DFE1E0";
  static const char *colors[][3]      = {
! 	/*                  fg             bg            border   */
! 	[SchemeNorm]    = { col_gainsboro, col_gunmetal, col_gunmetal },
! 	[SchemeSel]     = { col_platinum,  col_charcoal, col_charcoal },
! 	[SchemeStatus]  = { col_gainsboro, col_gunmetal, "#000000"  }, // Statusbar right {text,background,not used but cannot be empty}
! 	[SchemeTagsSel] = { col_gainsboro, col_charcoal, "#000000"  }, // Tagbar left selected {text,background,not used but cannot be empty}
! 	[SchemeTagsNorm]= { col_gainsboro, col_gunmetal, "#000000"  }, // Tagbar left unselected {text,background,not used but cannot be empty}
! 	[SchemeInfoSel] = { col_platinum,  col_gunmetal, "#000000"  }, // infobar middle  selected {text,background,not used but cannot be empty}
! 	[SchemeInfoNorm]= { col_gainsboro, col_gunmetal, "#000000"  }, // infobar middle  unselected {text,background,not used but cannot be empty}
  };
*************** static char dmenumon[2] = "0"; /* compon
*** 60,62 ****
  static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
! static const char *termcmd[]  = { "st", NULL };
  
--- 71,73 ----
  static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
! static const char *termcmd[]  = { "kitty", NULL };
  
*************** static Key keys[] = {
*** 81,82 ****
--- 92,94 ----
  	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
+ 	{ MODKEY,                       XK_r,      togglermaster,  {0} },
  	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
diff -Np1 dwm-6.3/config.h dwm-mw-master/config.h
*** dwm-6.3/config.h	1969-12-31 16:00:00.000000000 -0800
--- dwm-mw-master/config.h	2022-02-10 10:52:31.569939408 -0800
***************
*** 0 ****
--- 1,124 ----
+ /* See LICENSE file for copyright and license details. */
+ 
+ /* appearance */
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
+ static const unsigned int bar_hpad  = 4;        /* default 2px above/below font size  */
+ static const int rmaster            = 0;        /* 1 means master-area is initially on the right */
+ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 1;        /* 0 means bottom bar */
+ static const char *fonts[]          = { "monospace:size=11" };
+ static const char dmenufont[]       = "monospace:size=11";
+ static const char col_gray1[]       = "#222222";
+ static const char col_gray2[]       = "#444444";
+ static const char col_gray3[]       = "#bbbbbb";
+ static const char col_gray4[]       = "#eeeeee";
+ static const char col_cyan[]        = "#005577";
+ static const char *colors[][3]      = {
+ 	/*               fg         bg         border   */
+ 	[SchemeNorm] = { col_gray3, col_cyan, col_gray2 },
+ 	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+ 	[SchemeStatus]  = { col_gray3, col_cyan,  "#000000"  }, // Statusbar right {text,background,not used but cannot be empty}
+ 	[SchemeTagsSel]  = { col_gray4, col_cyan,  "#000000"  }, // Tagbar left selected {text,background,not used but cannot be empty}
+     [SchemeTagsNorm]  = { col_gray3, col_cyan,  "#000000"  }, // Tagbar left unselected {text,background,not used but cannot be empty}
+     [SchemeInfoSel]  = { col_gray4, col_cyan,  "#000000"  }, // infobar middle  selected {text,background,not used but cannot be empty}
+     [SchemeInfoNorm]  = { col_gray3, col_cyan,  "#000000"  }, // infobar middle  unselected {text,background,not used but cannot be empty}
+ };
+ 
+ /* tagging */
+ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+ 
+ static const Rule rules[] = {
+ 	/* xprop(1):
+ 	 *	WM_CLASS(STRING) = instance, class
+ 	 *	WM_NAME(STRING) = title
+ 	 */
+ 	/* class      instance    title       tags mask     isfloating   monitor */
+ 	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
+ 	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
+ };
+ 
+ /* layout(s) */
+ static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+ static const int nmaster     = 1;    /* number of clients in master area */
+ static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+ static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
+ 
+ static const Layout layouts[] = {
+ 	/* symbol     arrange function */
+ 	{ "[]=",      tile },    /* first entry is default */
+ 	{ "><>",      NULL },    /* no layout function means floating behavior */
+ 	{ "[M]",      monocle },
+ };
+ 
+ /* key definitions */
+ #define MODKEY Mod1Mask
+ #define TAGKEYS(KEY,TAG) \
+ 	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
+ 
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+ 
+ /* commands */
+ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+ static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+ static const char *termcmd[]  = { "kitty", NULL };
+ 
+ static Key keys[] = {
+ 	/* modifier                     key        function        argument */
+ 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+ 	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
+ 	{ MODKEY,                       XK_b,      togglebar,      {0} },
+ 	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
+ 	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+ 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
+ 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+ 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+ 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+ 	{ MODKEY,                       XK_Return, zoom,           {0} },
+ 	{ MODKEY,                       XK_Tab,    view,           {0} },
+ 	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+ 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
+ 	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
+ 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
+ 	{ MODKEY,                       XK_space,  setlayout,      {0} },
+ 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
+ 	{ MODKEY,                       XK_r,      togglermaster,  {0} },
+ 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+ 	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+ 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
+ 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+ 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+ 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+ 	TAGKEYS(                        XK_1,                      0)
+ 	TAGKEYS(                        XK_2,                      1)
+ 	TAGKEYS(                        XK_3,                      2)
+ 	TAGKEYS(                        XK_4,                      3)
+ 	TAGKEYS(                        XK_5,                      4)
+ 	TAGKEYS(                        XK_6,                      5)
+ 	TAGKEYS(                        XK_7,                      6)
+ 	TAGKEYS(                        XK_8,                      7)
+ 	TAGKEYS(                        XK_9,                      8)
+ 	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+ };
+ 
+ /* button definitions */
+ /* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
+ static Button buttons[] = {
+ 	/* click                event mask      button          function        argument */
+ 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+ 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+ 	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
+ 	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+ 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+ 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+ 	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+ 	{ ClkTagBar,            0,              Button1,        view,           {0} },
+ 	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
+ 	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+ 	{ ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
+ };
+ 
diff -Np1 dwm-6.3/dwm.c dwm-mw-master/dwm.c
*** dwm-6.3/dwm.c	2022-01-07 03:42:18.000000000 -0800
--- dwm-mw-master/dwm.c	2022-02-10 10:51:54.372509963 -0800
***************
*** 61,63 ****
  enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
! enum { SchemeNorm, SchemeSel }; /* color schemes */
  enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
--- 61,63 ----
  enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
! enum { SchemeNorm, SchemeSel, SchemeStatus, SchemeTagsSel, SchemeTagsNorm, SchemeInfoSel, SchemeInfoNorm }; /* color schemes */
  enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
*************** typedef struct {
*** 113,114 ****
--- 113,115 ----
  
+ typedef struct Pertag Pertag;
  struct Monitor {
*************** struct Monitor {
*** 124,125 ****
--- 125,127 ----
  	unsigned int tagset[2];
+ 	int rmaster;
  	int showbar;
*************** struct Monitor {
*** 132,133 ****
--- 134,136 ----
  	const Layout *lt[2];
+ 	Pertag *pertag;
  };
*************** static void togglebar(const Arg *arg);
*** 214,215 ****
--- 217,219 ----
  static void togglefloating(const Arg *arg);
+ static void togglermaster(const Arg *arg);
  static void toggletag(const Arg *arg);
*************** static Window root, wmcheckwin;
*** 274,275 ****
--- 278,288 ----
  
+ struct Pertag {
+ 	unsigned int curtag, prevtag; /* current and previous tag */
+ 	int nmasters[LENGTH(tags) + 1]; /* number of windows in master area */
+ 	float mfacts[LENGTH(tags) + 1]; /* mfacts per tag */
+ 	unsigned int sellts[LENGTH(tags) + 1]; /* selected layouts */
+ 	const Layout *ltidxs[LENGTH(tags) + 1][2]; /* matrix of tags and layouts indexes  */
+ 	int showbars[LENGTH(tags) + 1]; /* display bar for the current tag */
+ };
+ 
  /* compile-time check if all tags fit into an unsigned int bit array. */
*************** createmon(void)
*** 634,635 ****
--- 647,649 ----
  	Monitor *m;
+ 	unsigned int i;
  
*************** createmon(void)
*** 639,640 ****
--- 653,655 ----
  	m->nmaster = nmaster;
+ 	m->rmaster = rmaster;
  	m->showbar = showbar;
*************** createmon(void)
*** 644,645 ****
--- 659,674 ----
  	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+ 	m->pertag = ecalloc(1, sizeof(Pertag));
+ 	m->pertag->curtag = m->pertag->prevtag = 1;
+ 
+ 	for (i = 0; i <= LENGTH(tags); i++) {
+ 		m->pertag->nmasters[i] = m->nmaster;
+ 		m->pertag->mfacts[i] = m->mfact;
+ 
+ 		m->pertag->ltidxs[i][0] = m->lt[0];
+ 		m->pertag->ltidxs[i][1] = m->lt[1];
+ 		m->pertag->sellts[i] = m->sellt;
+ 
+ 		m->pertag->showbars[i] = m->showbar;
+ 	}
+ 
  	return m;
*************** drawbar(Monitor *m)
*** 709,711 ****
  	if (m == selmon) { /* status is only drawn on selected monitor */
! 		drw_setscheme(drw, scheme[SchemeNorm]);
  		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
--- 738,740 ----
  	if (m == selmon) { /* status is only drawn on selected monitor */
! 		drw_setscheme(drw, scheme[SchemeStatus]);
  		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
*************** drawbar(Monitor *m)
*** 722,724 ****
  		w = TEXTW(tags[i]);
! 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
  		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
--- 751,753 ----
  		w = TEXTW(tags[i]);
! 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeTagsSel : SchemeTagsNorm]);
  		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
*************** drawbar(Monitor *m)
*** 731,733 ****
  	w = blw = TEXTW(m->ltsymbol);
! 	drw_setscheme(drw, scheme[SchemeNorm]);
  	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
--- 760,762 ----
  	w = blw = TEXTW(m->ltsymbol);
! 	drw_setscheme(drw, scheme[SchemeTagsNorm]);
  	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
*************** drawbar(Monitor *m)
*** 736,738 ****
  		if (m->sel) {
! 			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
  			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
--- 765,767 ----
  		if (m->sel) {
! 			drw_setscheme(drw, scheme[m == selmon ? SchemeInfoSel : SchemeInfoNorm]);
  			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
*************** drawbar(Monitor *m)
*** 741,743 ****
  		} else {
! 			drw_setscheme(drw, scheme[SchemeNorm]);
  			drw_rect(drw, x, 0, w, bh, 1, 1);
--- 770,772 ----
  		} else {
! 			drw_setscheme(drw, scheme[SchemeInfoNorm]);
  			drw_rect(drw, x, 0, w, bh, 1, 1);
*************** incnmaster(const Arg *arg)
*** 972,974 ****
  {
! 	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
  	arrange(selmon);
--- 1001,1003 ----
  {
! 	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);
  	arrange(selmon);
*************** setlayout(const Arg *arg)
*** 1507,1511 ****
  	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
! 		selmon->sellt ^= 1;
  	if (arg && arg->v)
! 		selmon->lt[selmon->sellt] = (Layout *)arg->v;
  	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
--- 1536,1540 ----
  	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
! 		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
  	if (arg && arg->v)
! 		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (Layout *)arg->v;
  	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
*************** setmfact(const Arg *arg)
*** 1528,1530 ****
  		return;
! 	selmon->mfact = f;
  	arrange(selmon);
--- 1557,1559 ----
  		return;
! 	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
  	arrange(selmon);
*************** setup(void)
*** 1551,1553 ****
  	lrpad = drw->fonts->h;
! 	bh = drw->fonts->h + 2;
  	updategeom();
--- 1580,1582 ----
  	lrpad = drw->fonts->h;
! 	bh = drw->fonts->h + bar_hpad;
  	updategeom();
*************** tile(Monitor *m)
*** 1687,1689 ****
  	if (n > m->nmaster)
! 		mw = m->nmaster ? m->ww * m->mfact : 0;
  	else
--- 1716,1720 ----
  	if (n > m->nmaster)
! 		mw = m->nmaster
! 			? m->ww * (m->rmaster ? 1.0 - m->mfact : m->mfact)
! 			: 0;
  	else
*************** tile(Monitor *m)
*** 1693,1695 ****
  			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
! 			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
  			if (my + HEIGHT(c) < m->wh)
--- 1724,1727 ----
  			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
! 			resize(c, m->rmaster ? m->wx + m->ww - mw : m->wx,
! 			       m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
  			if (my + HEIGHT(c) < m->wh)
*************** tile(Monitor *m)
*** 1698,1700 ****
  			h = (m->wh - ty) / (n - i);
! 			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
  			if (ty + HEIGHT(c) < m->wh)
--- 1730,1733 ----
  			h = (m->wh - ty) / (n - i);
! 			resize(c, m->rmaster ? m->wx : m->wx + mw, m->wy + ty,
! 			       m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
  			if (ty + HEIGHT(c) < m->wh)
*************** togglebar(const Arg *arg)
*** 1707,1709 ****
  {
! 	selmon->showbar = !selmon->showbar;
  	updatebarpos(selmon);
--- 1740,1742 ----
  {
! 	selmon->showbar = selmon->pertag->showbars[selmon->pertag->curtag] = !selmon->showbar;
  	updatebarpos(selmon);
*************** togglefloating(const Arg *arg)
*** 1728,1729 ****
--- 1761,1772 ----
  void
+ togglermaster(const Arg *arg)
+ {
+ 	selmon->rmaster = !selmon->rmaster;
+ 	/* now mfact represents the left factor */
+ 	selmon->mfact = 1.0 - selmon->mfact;
+ 	if (selmon->lt[selmon->sellt]->arrange)
+ 		arrange(selmon);
+ }
+ 
+ void
  toggletag(const Arg *arg)
*************** toggleview(const Arg *arg)
*** 1746,1747 ****
--- 1789,1791 ----
  	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
+ 	int i;
  
*************** toggleview(const Arg *arg)
*** 1749,1750 ****
--- 1793,1817 ----
  		selmon->tagset[selmon->seltags] = newtagset;
+ 
+ 		if (newtagset == ~0) {
+ 			selmon->pertag->prevtag = selmon->pertag->curtag;
+ 			selmon->pertag->curtag = 0;
+ 		}
+ 
+ 		/* test if the user did not select the same tag */
+ 		if (!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
+ 			selmon->pertag->prevtag = selmon->pertag->curtag;
+ 			for (i = 0; !(newtagset & 1 << i); i++) ;
+ 			selmon->pertag->curtag = i + 1;
+ 		}
+ 
+ 		/* apply settings for this view */
+ 		selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+ 		selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+ 		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+ 		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+ 		selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+ 
+ 		if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+ 			togglebar(NULL);
+ 
  		focus(NULL);
*************** view(const Arg *arg)
*** 2043,2044 ****
--- 2110,2114 ----
  {
+ 	int i;
+ 	unsigned int tmptag;
+ 
  	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
*************** view(const Arg *arg)
*** 2046,2049 ****
  	selmon->seltags ^= 1; /* toggle sel tagset */
! 	if (arg->ui & TAGMASK)
  		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
  	focus(NULL);
--- 2116,2142 ----
  	selmon->seltags ^= 1; /* toggle sel tagset */
! 	if (arg->ui & TAGMASK) {
  		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+ 		selmon->pertag->prevtag = selmon->pertag->curtag;
+ 
+ 		if (arg->ui == ~0)
+ 			selmon->pertag->curtag = 0;
+ 		else {
+ 			for (i = 0; !(arg->ui & 1 << i); i++) ;
+ 			selmon->pertag->curtag = i + 1;
+ 		}
+ 	} else {
+ 		tmptag = selmon->pertag->prevtag;
+ 		selmon->pertag->prevtag = selmon->pertag->curtag;
+ 		selmon->pertag->curtag = tmptag;
+ 	}
+ 
+ 	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+ 	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+ 	selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+ 	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+ 	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+ 
+ 	if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+ 		togglebar(NULL);
+ 
  	focus(NULL);
